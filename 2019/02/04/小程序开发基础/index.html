
<!DOCTYPE html>
<html lang="en" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>小程序开发基础 - GYK</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="node,"> 
    <meta name="description" content="Lonely&#39;s blog,BOTTOM

微信小程序开发
1.了解微信端开发
2.小程序开发准备工作
3.学习小程序基础语言
4.学习小程序内置组件
5.学习小程序API
6.目录结构层级
7.请求封装方案
8.缓存机制
9,"> 
    <meta name="author" content="kk"> 
    <link rel="alternative" href="atom.xml" title="GYK" type="application/atom+xml"> 
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">GYK</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="https://gaoyakang.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">小程序开发基础</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">小程序开发基础</h1>
        <div class="stuff">
            <span>二月 04, 2019</span>
            

        </div>
        <div class="content markdown">
            <div style="text-align:center;margin:30px;font-size:20px;border-radius:5px;border:3px solid #eee; cursor:pointer;" onclick="javascript:window.scrollTo(0, document.body.clientHeight)">BOTTOM</div>

<h1 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h1><ul>
<li>1.了解微信端开发</li>
<li>2.小程序开发准备工作</li>
<li>3.学习小程序基础语言</li>
<li>4.学习小程序内置组件</li>
<li>5.学习小程序API</li>
<li>6.目录结构层级</li>
<li>7.请求封装方案</li>
<li>8.缓存机制</li>
<li>9.用户认证处理</li>
<li>10.常用的操作</li>
</ul>
<h2 id="微信端开发"><a href="#微信端开发" class="headerlink" title="微信端开发"></a>微信端开发</h2><p><code>现在微信支持小程序，小游戏，订阅号和服务号开发，</code></p>
<ul>
<li>①服务号适用于企业组织(招商银行，东方航空)</li>
<li>②订阅号适用于个人媒体(吃货请闭眼，老黄私房菜)</li>
<li>③小程序适用于需要在微信内提供应用的客户(在线商城，地图导航)</li>
<li>④小游戏适用于需要在微信推广游戏项目的客户(跳一跳，俄罗斯方块)</li>
</ul>
<h2 id="小程序开发准备工作"><a href="#小程序开发准备工作" class="headerlink" title="小程序开发准备工作"></a>小程序开发准备工作</h2><ul>
<li>①申请账号(该账号下不允许有任何微信端产品，必须使用新账号，后用开发者微信登录)</li>
<li>②填写小程序基础信息(在后台填写名称，头像，简介，类目)</li>
<li>③获得开发者appkey(必须填写完基础信息才能获得)</li>
<li>④下载开发者工具后，开发者扫码登录，新建项目(可以选择云开发也可以选择非云开发，都需要appkey)</li>
<li>⑤熟悉开发者工具界面(代码区/预览区/调试区)</li>
<li>⑥开始开发项目</li>
<li>⑦打包项目直接提交即可(注意服务调用的请求必须为https)</li>
</ul>
<h2 id="小程序开发语言"><a href="#小程序开发语言" class="headerlink" title="小程序开发语言"></a>小程序开发语言</h2><p><code>开发小程序与前端开发体验相似，但是小程序实际上是微信内部的应用，它本身的逻辑进程(jsCore)与渲染进程(webView)是分离的，我们所要处理的是安卓与苹果两大机型，启动一个新项目，小程序开发者工具会先去app.json中查找全局配置，在这里我们可以设置页面路径，顶部样式，底部导航，后台播放，跳转程序，接着就能到对应页面开发了，在页面上小程序采用了wxml，wxss，js和json四种语法，在js中可以使用全局的api(wx.xxx)来调用微信功能</code></p>
<ul>
<li>①wxml: 负责页面结构，可以用双花括号引入变量，也可用wx:for/if/hidden等进行判断，还可用bind:tap=”绑定事件”，注意这里需要使用双引号，不允许有空隙，”true“才表示正确逻辑表达，wx:for渲染的项目默认叫item，template可以封装使用的模板通过import引入，wxs文件引入时需要指定module名称，</li>
<li>②wxss: 负责页面样式，尺寸使用rpx(与iPhone6设计稿1:1比例)</li>
<li>③js: 负责页面逻辑，分全局(App)，页面级(page)和组件级(component)，有各种配置，全局只有一个实例</li>
<li>④json: 负责配置，分全局(app)，页面和组件级三种  </li>
</ul>
<h2 id="小程序内置组件"><a href="#小程序内置组件" class="headerlink" title="小程序内置组件"></a>小程序内置组件</h2><p><code>小程序中wxml中的组件是在html基本标签基础上的进一步封装，在html中，它们只是代表元素类型，在wxml中它们除了代表不同元素类型，还代表不同功能，分别包括基础，视图，表单，导航，媒体，地图，画布等组件，基础的view，text，button等最常使用</code><br><code>更多的组件看: https://developers.weixin.qq.com/miniprogram/dev/component/</code></p>
<h2 id="小程序API"><a href="#小程序API" class="headerlink" title="小程序API"></a>小程序API</h2><p><code>小程序api是指可以在当前实例任意js文件中调用的功能接口，它们主要分为:</code></p>
<ul>
<li>①路由wx.navigateTo({url:”xx”})</li>
<li>②缓存wx.setStorageSync(key,value)</li>
<li>③网络wx.request({url:”xxx”})</li>
<li>④位置wx.getLocation({ })</li>
<li>⑤用户wx.getUserInfo({})</li>
<li>⑥界面<br>  – 1.wx.showToast({})<br>  – 2.wx.showLoading({})<br>  – 3.wx.pageScrollTo({})</li>
</ul>
<p><code>更多api看: https://developers.weixin.qq.com/miniprogram/dev/api/</code></p>
<h2 id="目录结构层级"><a href="#目录结构层级" class="headerlink" title="目录结构层级"></a>目录结构层级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- blink</span><br><span class="line">  - components</span><br><span class="line">    - behaviors(公用行为)</span><br><span class="line">    - loading(公用组件)</span><br><span class="line">  - images</span><br><span class="line">  - models</span><br><span class="line">    - home.js(封装请求，处理参数)</span><br><span class="line">  - pages</span><br><span class="line">    - home</span><br><span class="line">      - home.wxml</span><br><span class="line">      - home.wxss</span><br><span class="line">      - home.js</span><br><span class="line">      - home.json</span><br><span class="line">  - util</span><br><span class="line">    - http.js(封装请求，处理错误)</span><br><span class="line">  - app.jsonx</span><br></pre></td></tr></table></figure>

<h2 id="请求封装方案"><a href="#请求封装方案" class="headerlink" title="请求封装方案"></a>请求封装方案</h2><p><code>微信内的请求是通过wx.request()来是实现的，但是它居然是以回调的方式来处理结果的，需要把它改成promise版本的，具体如下：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 封装request请求，添加错误处理</span><br><span class="line">import &#123; config &#125; from &apos;../config.js&apos;</span><br><span class="line"></span><br><span class="line">const tips = &#123;</span><br><span class="line">  1:&quot;抱歉，出现了一个错误&quot;,</span><br><span class="line">  1005:&quot;appkey无效&quot;,</span><br><span class="line">  3000:&quot;期刊不存在&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HTTP&#123;</span><br><span class="line">  request(&#123;url,data=&#123;&#125;,method=&apos;GET&apos;&#125;)&#123;</span><br><span class="line">    return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">      this._request(url,resolve,reject,data,method)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _request(url,resolve,reject,data=&#123;&#125;,method=&apos;GET&apos;)&#123;</span><br><span class="line">    //url data method</span><br><span class="line">  	wx.request(&#123;</span><br><span class="line">  	  url: config.api_base_url + url,</span><br><span class="line">  	  method: method,</span><br><span class="line">  	  data: data,</span><br><span class="line">  	  header: &#123;</span><br><span class="line">  	    &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">  	    &apos;appkey&apos;: config.appkey</span><br><span class="line">  	  &#125;,</span><br><span class="line">  	  success: (res) =&gt; &#123;</span><br><span class="line">  	  	const code = res.statusCode.toString()</span><br><span class="line">  	  	if(code.startsWith(&apos;2&apos;))&#123;</span><br><span class="line">          resolve(res.data)</span><br><span class="line">  	  	&#125;else&#123;</span><br><span class="line">          reject()</span><br><span class="line">          const error_code = res.data.error_code</span><br><span class="line">          this._showw_error(error_code)</span><br><span class="line">  	  	&#125;</span><br><span class="line">  	  &#125;,</span><br><span class="line">  	  fail: (err) =&gt; &#123;</span><br><span class="line">        reject()</span><br><span class="line">        this._showw_error(1)</span><br><span class="line">  	  &#125;</span><br><span class="line">  	&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _showw_error(error_code)&#123;</span><br><span class="line">    if(!error_code)&#123;</span><br><span class="line">      error_code = 1</span><br><span class="line">    &#125;</span><br><span class="line">    const tip = tips[error_code]</span><br><span class="line">    wx.showToast(&#123;</span><br><span class="line">          title: tip?tip:tips[1],</span><br><span class="line">          icon: &apos;none&apos;,</span><br><span class="line">          duration: 2000</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;HTTP&#125;</span><br></pre></td></tr></table></figure>

<p><code>这样在具体的调用时再把请求的方法封装在不同的类中，页面上只负责调用方法，请求的错误处理，参数处理全部封装起来：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HTTP&#125; from &apos;../util/http-p.js&apos;</span><br><span class="line"></span><br><span class="line">class BookModel extends HTTP&#123;</span><br><span class="line">  getHotList()&#123;</span><br><span class="line">  	return this.request(&#123;url:&apos;book/hot_list&apos;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;BookModel&#125;</span><br></pre></td></tr></table></figure>

<p><code>实际调用的只是封装好的方法：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const bookList = bookModel.getHotList()</span><br><span class="line">    bookList.then(res=&gt;&#123;</span><br><span class="line">      // console.log(res)</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        books:res</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><code>页面加载数据后，当再次访问这个页面时并不需要再次加载数据，所以就可以在第一次请求数据时就把数据先存起来，每次发心情求时就先去访问缓存中的数据，如果有就使用缓存中的数据，如果没有就发起新的请求，具体的请求挨批如下：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wx.setStorageSync(key,res)</span><br><span class="line">wx.getStorageSync(key)</span><br></pre></td></tr></table></figure>

<h2 id="用户认证处理方案"><a href="#用户认证处理方案" class="headerlink" title="用户认证处理方案"></a>用户认证处理方案</h2><p><code>小程序的认证是指调用接口获得用户的信息，在微信中必须调用官方提供的button组件来实现，但有时候需要实现自定的样式，所以就需要对button进行封装，这里将其封装成一个名为image-button的图片组件，通过插槽将需要的样式传入，而不使用微信自带的丑样式：</code><br><code>在button上绑定的getuserinfo事件是官方规定的事件，监听该事件就能在用户点击登录时获得用户的相关信息然后将获取到的用户信息发送页认证的页面上</code><br><code>封装组件</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button bind:getuserinfo=&quot;onGetUserInfo&quot; </span><br><span class="line">    open-type=&apos;&#123;&#123;openType&#125;&#125;&apos;  plain=&apos;&#123;&#123;true&#125;&#125;&apos;</span><br><span class="line">     class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;slot name=&quot;img&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    padding: 0 !important;</span><br><span class="line">    border:none !important;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>此时button组件上的openType是从页面传来的属性，所以需要在组件的js中接收一下，然后用户点击了就可以把获得的信息提交到页面上</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// components/image-button/index.js</span><br><span class="line">Component(&#123;</span><br><span class="line">  /**</span><br><span class="line">   * 组件的属性列表</span><br><span class="line">   */</span><br><span class="line">  options: &#123;</span><br><span class="line">    multipleSlots: true </span><br><span class="line">  &#125;,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    openType: &#123;</span><br><span class="line">      type: String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 组件的初始数据</span><br><span class="line">   */</span><br><span class="line">  data: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 组件的方法列表</span><br><span class="line">   */</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onGetUserInfo(event)&#123;</span><br><span class="line">      this.triggerEvent(&apos;getuserinfo&apos;, event.detail, &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>页面调用组件</code><br><code>提交到页面上以后，在页面上监听该事件，获得用户信息</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;v-button </span><br><span class="line">    wx:if=&quot;&#123;&#123;!authorized&#125;&#125;&quot; </span><br><span class="line">    open-type=&quot;getUserInfo&quot; </span><br><span class="line">    class=&quot;avatar-position&quot; </span><br><span class="line">    bind:getuserinfo=&quot;onGetUserInfo&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;image slot=&quot;img&quot; class=&quot;avatar&quot; src=&quot;/images/my/my.png&quot; /&gt;</span><br><span class="line">  &lt;/v-button&gt;</span><br></pre></td></tr></table></figure>

<p><code>首先在页面上先来判断是不是认证过了，接着点击的时候如果认证过了就不再认证，否则就去再认证</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">onShow(options) &#123;</span><br><span class="line">    this.userAuthorized2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async userAuthorized2()&#123;</span><br><span class="line">    const data = await promisic(wx.getSetting)()</span><br><span class="line">    if (data.authSetting[&apos;scope.userInfo&apos;]) &#123;</span><br><span class="line">       const res =  await promisic(wx.getUserInfo)()</span><br><span class="line">       const userInfo = res.userInfo</span><br><span class="line">       this.setData(&#123;</span><br><span class="line">         authorized: true,</span><br><span class="line">         userInfo</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">onGetUserInfo(event) &#123;</span><br><span class="line">    const userInfo = event.detail.userInfo</span><br><span class="line">    if (userInfo) &#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        userInfo,</span><br><span class="line">        authorized: true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="常用的操作"><a href="#常用的操作" class="headerlink" title="常用的操作"></a>常用的操作</h2><p><code>有一些经常使用的操作和思路总是忘记，记录下来供以后ctrl+c/v</code></p>
<ul>
<li>1.页面中能有组件切换就不用页面跳转</li>
<li>2.多组件的常用行为抽离在behaviors中</li>
</ul>
<div style="text-align:center;margin:30px;font-size:20px;border-radius:5px;border:3px solid #eee; cursor:pointer;" onclick="javascript:window.scrollTo(0, 0)">TOP</div>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
