
<!DOCTYPE html>
<html lang="en" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>js类的创建与继承 - GYK</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="node,"> 
    <meta name="description" content="Lonely&#39;s blog,BOTTOM


JS类的创建与继承对象的概念学习过其他高级语言的人都有默认的认识『类: 模板，对象: 实例』，对象的创建需要用到new className，这说明在其他语言中，对象就是一种独有的数,"> 
    <meta name="author" content="kk"> 
    <link rel="alternative" href="atom.xml" title="GYK" type="application/atom+xml"> 
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">GYK</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="https://gaoyakang.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">js类的创建与继承</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">js类的创建与继承</h1>
        <div class="stuff">
            <span>六月 15, 2018</span>
            

        </div>
        <div class="content markdown">
            <div style="text-align:center;margin:30px;font-size:20px;border-radius:5px;border:3px solid #eee; cursor:pointer;" onclick="javascript:window.scrollTo(0, document.body.clientHeight)">BOTTOM</div>


<h1 id="JS类的创建与继承"><a href="#JS类的创建与继承" class="headerlink" title="JS类的创建与继承"></a>JS类的创建与继承</h1><h2 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h2><p><code>学习过其他高级语言的人都有默认的认识『类: 模板，对象: 实例』，对象的创建需要用到new className，这说明在其他语言中，对象就是一种独有的数据集合，它能添加属性与方法，即对象是对象，仅此而已;</code></p>
<p><code>在js中，判断一个变量是不是对象，可以通过不同类型判断符来确定，值类型的用typeof判断，引用类型用instanceof判断，js中的引用类型有函数、数组、对象、new Number(10)等，对象的创建需要用到new FunctionName，这说明在js中类与对象的概念更加的宽松，对象的概念泛化了，它通过添加属性来扩展自己，函数，数组，对象等等都是对象，即对象是指一切引用类型的数据。</code></p>
<table>
<thead>
<tr>
<th align="center">js对象</th>
<th align="center">其他语言对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一切引用类型数据</td>
<td align="center">单独数据集合</td>
</tr>
</tbody></table>
<h2 id="对象与函数关系"><a href="#对象与函数关系" class="headerlink" title="对象与函数关系"></a>对象与函数关系</h2><p><code>通过上面的对比知道了函数属于引用类型，引用类型又都是对象，所以函数是对象，但对象又是通过new 函数的方式来创建，也就是说对象 = new 对象，表面上看起来不合逻辑，那对象与函数之间的关系是什么呢？</code></p>
<ul>
<li>①每个函数都有自带属性prototype(显式原型)，它的取值是个对象，该对象默认只有一个叫做constructor的属性，指向这个函数本身。</li>
<li>②每个对象都有隐藏属性__proto__(隐式原型)，该属性指向创建当前对象的函数的prototype。即：fn.__proto__ === Fn.prototype</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">prototype(显式原型)</td>
<td align="center">__proto__(隐式原型)</td>
</tr>
<tr>
<td align="center">↓</td>
<td align="center">↓</td>
</tr>
<tr>
<td align="center">通过constructor指向函数</td>
<td align="center">指向函数显式原型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">==================================================================</span><br><span class="line"> 函    数  —   (__proto__隐式原型)</span><br><span class="line">  ↑    |               |</span><br><span class="line">  ↑       |            |</span><br><span class="line">  ↑      (  | prototype显式原型)</span><br><span class="line">  ↑              ↓           ↓</span><br><span class="line">  ↑  ← counstructor     (__proto__隐式原型)</span><br><span class="line">                                 ↓</span><br><span class="line"> func Object()→  ( func Object()显式原型)</span><br><span class="line">  ↑              ↓    |          ↓</span><br><span class="line">  ↑  ← counstructor   |  (__proto__隐式原型)</span><br><span class="line">                       |          ↓</span><br><span class="line">                       | ____   null</span><br><span class="line">===================================================================</span><br></pre></td></tr></table></figure>

<p><img src="//gaoyakang.github.io/2018/06/15/js类的创建与继承/3.png" alt="sd"><br><code>也就是说new FunctionName时，由于函数是对象也是函数，所以它既有隐式原型，又有显式原型，函数的隐式原型指向自身显式原型，显示原型又通过constructor属性指向函数本身，显式原型又是个对象，所以显式原型也有自己的隐式原型，即显式原型的隐式原型，该隐式原型指向【创建该显示原型对象的函数的显式原型】，那【创建该显示原型对象的函数的显式原型】是谁呢？答案是Object.prototype，所以不是对象 = new 对象，而是对象 = new Object.prototype，对象本质上是被Object函数创建的，因此对象.__proto__=== Object.prototype，Object同样有自己的prototype显式原型，它本应该指向函数本身，但这是一个特例——它指向null，即它的__proto__指向的也是null。</code></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><code>通过讲对象与函数的关系，我们知道了原型对象，那原型对象有什么用呢？接下来通过instance来说明：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;</span><br><span class="line">let f1 = new Foo()</span><br><span class="line">f1 instanceof Foo</span><br><span class="line">f1 instanceof Object</span><br></pre></td></tr></table></figure>

<p><code>这里f1 instanceof Object”为什么是true呢?</code><br><code>因为Instanceof的判断规则是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false</code><br><img src="//gaoyakang.github.io/2018/06/15/js类的创建与继承/2.png" alt="xs"><br><code>得出原型链概念: 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找</code></p>
<h2 id="es5类的创建与继承"><a href="#es5类的创建与继承" class="headerlink" title="es5类的创建与继承"></a>es5类的创建与继承</h2><p><code>了解了对象的概念，对象与函数的关系，原型链概念以后，我们就能合理解释es5类的创建与继承了，在es5中构造函数，原型对象，原型链等一系列的概念共同合作实现了类的创建与继承，作为类应支持公有、私有，静态属性和方法等，一个类还必须满足封装继承和多态三大性质，如何来实现呢？</code></p>
<h3 id="工厂模式实现类功能"><a href="#工厂模式实现类功能" class="headerlink" title="工厂模式实现类功能"></a>工厂模式实现类功能</h3><p><code>最开始用的方法是Object</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function showColor() &#123;</span><br><span class="line">  alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">function createCar() &#123;</span><br><span class="line">  var oTempCar = new Object;</span><br><span class="line">  oTempCar.color = &quot;blue&quot;;</span><br><span class="line">  oTempCar.doors = 4;</span><br><span class="line">  oTempCar.mpg = 25;</span><br><span class="line">  oTempCar.showColor = showColor;</span><br><span class="line">  return oTempCar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var oCar1 = createCar();</span><br><span class="line">var oCar2 = createCar();</span><br></pre></td></tr></table></figure>

<p><code>注意到上面除了object还用了一个function createCar，其实这是工厂模式，避免了重复去new object，同时内部的方法以属性的形式来进行关联，避免了每次调用工厂函数的时候重复生成对应的方法</code></p>
<h3 id="构造-原型实现类功能"><a href="#构造-原型实现类功能" class="headerlink" title="构造+原型实现类功能"></a>构造+原型实现类功能</h3><p><code>会发现虽然上述的工厂函数实现了属性和方法的功能，但是属性和方法是分离开的啊，有没有办法解决呢？用构造函数+原型对象，构造函数本质上就是一个首字母大写的函数，只不过调用的时候是用new关键字来进行生成，原型对象是为了解决类的方法重复创建的问题，所以将方法保存在原型对象中，然后在调用时沿着原型链去寻找，那如何把方法绑定在原型对象上呢？函数都有prototype原型对象啊，具体看代码，</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Car(sColor,iDoors,iMpg) &#123;</span><br><span class="line">  this.color = sColor;</span><br><span class="line">  this.doors = iDoors;</span><br><span class="line">  this.mpg = iMpg;</span><br><span class="line">  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.showColor = function() &#123;</span><br><span class="line">  alert(this.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var oCar1 = new Car(&quot;red&quot;,4,23);</span><br><span class="line">var oCar2 = new Car(&quot;blue&quot;,3,25);</span><br><span class="line"></span><br><span class="line">oCar1.drivers.push(&quot;Bill&quot;);</span><br><span class="line"></span><br><span class="line">alert(oCar1.drivers);	//输出 &quot;Mike,John,Bill&quot;</span><br><span class="line">alert(oCar2.drivers);	//输出 &quot;Mike,John&quot;</span><br></pre></td></tr></table></figure>

<p><code>会发现在构造函数内没有创建对象，而是使用 this 关键字，新建实例时使用new 运算符，那他们都干了啥？</code></p>
<p><code>1.new先新建了个空对象，就像在刚才的工厂函数中new Object()一样，怎么证明呢？在控制台测试一下</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var Test = function()&#123;&#125;</span><br><span class="line">console.log(typeof Test)//function</span><br><span class="line">var test = new Test()</span><br><span class="line">console.log(typeof test)//object</span><br></pre></td></tr></table></figure>

<p><code>会发现经过new后test的类型变成了object</code></p>
<p><code>2.接着Car.__proto__=car.prototype,将实例的原型对象指向构造函数的原型对象，为什么这么做呢，因为在工厂函数中我们给对象添加方法是直接通过oTempCar.showColor = showColor;，但通过构造+原型的方式来进行添加函数时，函数是被放在构造函数的原型对象里的，这是为了在调用时避免重复生成方法，所以实例对象要想访问到构造函数的方法，就必须要将自己的原型对象指向构造函数的原型对象，此时就可以访问到对应的方法了</code><br><code>3.再接着car.call(Car),把this指向当前的对象，这是因为在普通函里，this指向的是全局，只有进行修改后才能指向当前对象，这样的话就能像工厂函数那样的进行属性赋值了</code><br><code>这样说太抽象，做了张图大家看看：</code><br><img src="//gaoyakang.github.io/2018/06/15/js类的创建与继承/1.png" alt="dkkfi"></p>
<p><code>前面曾经说过this需要进行绑定，因为在不同的作用域下this所指代的内容是不同的，所以在这里看一下this到底会指向什么东西</code><br><code>首先是全局作用域下的this：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(this)</span><br><span class="line">//Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;</span><br></pre></td></tr></table></figure>

<p><code>接着是对象内的this：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    user:&quot;kk&quot;,</span><br><span class="line">	a:function()&#123;</span><br><span class="line">		console.log(this.user)</span><br><span class="line">		&#125;,</span><br><span class="line">    b: &#123;</span><br><span class="line">        user: &quot;gg&quot;,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">obj.a();//kk</span><br><span class="line">obj.b.fn();//gg</span><br></pre></td></tr></table></figure>

<p><code>再来是函数内的this：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function test()&#123;</span><br><span class="line">	console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">test();//1</span><br></pre></td></tr></table></figure>

<p><code>还有构造函数中的this：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Main()&#123;</span><br><span class="line">    this.def = function()&#123;</span><br><span class="line">                console.log(this === main);</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Main.prototype.foo = function()&#123;</span><br><span class="line">    console.log(this === main);</span><br><span class="line">&#125;</span><br><span class="line">var main = new Main();</span><br><span class="line">main.def(); //true</span><br><span class="line">main.foo();//true</span><br></pre></td></tr></table></figure>

<p><code>得出了什么结论呢？this永远指向最后调用他的对象</code></p>
<h3 id="对象冒充继承"><a href="#对象冒充继承" class="headerlink" title="对象冒充继承"></a>对象冒充继承</h3><p><code>上面已经实现了js中类的创建，下一步要解决是类的继承，最常用的有对象冒充继承，原型链继承和混合继承</code><br><code>首先说对象冒充继承，本质就是把父类作为子类的一个方法，然后来调用它，具体看代码：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function ClassA(sColor) &#123;</span><br><span class="line">    this.color = sColor;</span><br><span class="line">    this.sayColor = function () &#123;</span><br><span class="line">        alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function ClassB(sColor, sName) &#123;</span><br><span class="line">    this.newMethod = ClassA;</span><br><span class="line">    this.newMethod(sColor);</span><br><span class="line">    delete this.newMethod;</span><br><span class="line"></span><br><span class="line">    this.name = sName;</span><br><span class="line">    this.sayName = function () &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var objA = new ClassA(&quot;blue&quot;);</span><br><span class="line">var objB = new ClassB(&quot;red&quot;, &quot;John&quot;);</span><br><span class="line">objA.sayColor();	//输出 &quot;blue&quot;</span><br><span class="line">objB.sayColor();	//输出 &quot;red&quot;</span><br><span class="line">objB.sayName();		//输出 &quot;John&quot;</span><br></pre></td></tr></table></figure>

<p><code>父类作为子类的一个方法时当调用这个方法实际上父类的属性和方法就被子类继承了，同时我们还会发现delete this.newMethod;这句话，这是避免子类中新拓展的属性或者方法覆盖掉父类的属性方法,经过这样的冒用，就实现了子类的继承，同时这种方法还可以实现多重继承，也就是一个子类继承多个父类，但是，这样继承的父类中若果有重复的属性或者方法，会按照继承顺序来确定优先级，后继承的优先级高，具体看代码：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function ClassZ() &#123;</span><br><span class="line">    this.newMethod = ClassX;</span><br><span class="line">    this.newMethod();</span><br><span class="line">    delete this.newMethod;</span><br><span class="line"></span><br><span class="line">    this.newMethod = ClassY;</span><br><span class="line">    this.newMethod();</span><br><span class="line">    delete this.newMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>这种继承方法非常的流行，以至于官方后来扩展了call()和apply()来简化上面的操作，call()第一个参数就是子类，第二个参数就是需要传递的参数[字符串]，而apply()和call()的区别是，apply接受的参数形式为数组</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//call</span><br><span class="line">function ClassA(sColor) &#123;</span><br><span class="line">    this.color = sColor;</span><br><span class="line">    this.sayColor = function () &#123;</span><br><span class="line">        alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function ClassB(sColor, sName) &#123;</span><br><span class="line">    ClassA.call(this, sColor);</span><br><span class="line"></span><br><span class="line">    this.name = sName;</span><br><span class="line">    this.sayName = function () &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//apply</span><br><span class="line">function ClassA(sColor) &#123;</span><br><span class="line">    this.color = sColor;</span><br><span class="line">    this.sayColor = function () &#123;</span><br><span class="line">        alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function ClassB(sColor, sName) &#123;</span><br><span class="line">    ClassA.apply(this, new Array(sColor));</span><br><span class="line"></span><br><span class="line">    this.name = sName;</span><br><span class="line">    this.sayName = function () &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>做了张图，大家看看：</code><br><img src="//gaoyakang.github.io/2018/06/15/js类的创建与继承/4.png" alt="xsdt"></p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p><code>除了对象冒充继承，还可以使用原型链继承，原理是原型链最终会指向原型对象，换句话说，原型对象上的属性方法能被对象实例访问到，利用这个特性就可以实现继承，怎么做呢？ClassB.prototype = new ClassA();搞定，但要记住，子类的所有新属性和方法必须写在这句话后面，因为此时子类的原型对象实际上已经是A的实例所指向的原型对象，如果写在这句话前面，那新属性和方法就被挂载到了B的原型对象上去了，经过这句话赋值，那挂载的内容就相当于全被删了，切记切记，还有一点要知道，原型链继承并不能实现多重继承，这是因为原型对象只有一个，采用A的就不能用B的，否则就相当于把前一个删了。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function ClassA() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassA.prototype.color = &quot;blue&quot;;</span><br><span class="line">ClassA.prototype.sayColor = function () &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function ClassB() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = new ClassA();</span><br><span class="line"></span><br><span class="line">ClassB.prototype.name = &quot;&quot;;</span><br><span class="line">ClassB.prototype.sayName = function () &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var objA = new ClassA();</span><br><span class="line">var objB = new ClassB();</span><br><span class="line">objA.color = &quot;blue&quot;;</span><br><span class="line">objB.color = &quot;red&quot;;</span><br><span class="line">objB.name = &quot;John&quot;;</span><br><span class="line">objA.sayColor();</span><br><span class="line">objB.sayColor();</span><br><span class="line">objB.sayName();</span><br></pre></td></tr></table></figure>

<p><code>ClassB.prototype = new ClassA();是最重要的，它将ClassB 的 prototype 属性设置成 ClassA 的实例，获得了ClassA 的所有属性和方法</code></p>
<h3 id="混合继承"><a href="#混合继承" class="headerlink" title="混合继承"></a>混合继承</h3><p><code>对象冒充的主要问题是必须使用构造函数方式,使用原型链，就无法使用带参数的构造函数了,所以可以将两者结合起来：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function ClassA(sColor) &#123;</span><br><span class="line">    this.color = sColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassA.prototype.sayColor = function () &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function ClassB(sColor, sName) &#123;</span><br><span class="line">    ClassA.call(this, sColor);</span><br><span class="line">    this.name = sName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = new ClassA();</span><br><span class="line"></span><br><span class="line">ClassB.prototype.sayName = function () &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var objA = new ClassA(&quot;blue&quot;);</span><br><span class="line">var objB = new ClassB(&quot;red&quot;, &quot;John&quot;);</span><br><span class="line">objA.sayColor();	//输出 &quot;blue&quot;</span><br><span class="line">objB.sayColor();	//输出 &quot;red&quot;</span><br><span class="line">objB.sayName();	//输出 &quot;John&quot;</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><code>一个语言能使用类这个功能，说明它至少满足了类的三个特点，封装，继承和多态，前面说过了封装和继承，现在来说一下多态，多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。看了以后感觉很抽象，老办法，举例子，某人家里养了一只鸡，一只鸭，当主人向他们发出‘叫’的命令时。鸭子会嘎嘎的叫，而鸡会咯咯的叫，转换成代码如下:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var makeSound = function(animal) &#123;</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">Duck.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&apos;嘎嘎嘎&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var Chiken = function() &#123;&#125;;</span><br><span class="line">Chiken.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&apos;咯咯咯&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeSound(new Chicken());</span><br><span class="line">makeSound(new Duck());</span><br></pre></td></tr></table></figure>

<p><code>JavaScript中大多是通过子类重写父类方法的方式实现多态,具体看代码：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//使用es6 class简化代码</span><br><span class="line">class Parent &#123;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        console.log(&apos;Parent&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        console.log(&apos;Child&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function sayAge(object) &#123;</span><br><span class="line">    if ( object instanceof Child )&#123;</span><br><span class="line">        console.log( &apos;10&apos; );</span><br><span class="line">    &#125;else if ( object instanceof Parent )&#123;</span><br><span class="line">        console.log( &apos;30&apos; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayAge(child);   // &apos;10&apos;</span><br><span class="line">sayAge(parent);  // &apos;30&apos;</span><br></pre></td></tr></table></figure>

<p><code>很好玩，通过相同的操作但却得到了不同的结果，这个就是多态</code></p>
<h3 id="私有-静态属性和方法"><a href="#私有-静态属性和方法" class="headerlink" title="私有/静态属性和方法"></a>私有/静态属性和方法</h3><p><code>我们前面写的类的属性和方法都是公有的，但其实一个真正的类是包含只提供内部使用的私有属性方法和只提供类本身使用的静态属性和方法，接下来就一一实现一下：</code><br><code>首先是静态属性和方法，这个实现很简单，直接在类中添加就好了</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//添加静态属性</span><br><span class="line">Person.mouth = 1; </span><br><span class="line">//添加静态方法</span><br><span class="line">Person.cry = function() &#123;</span><br><span class="line">    alert(&apos;Wa wa wa …&apos;); </span><br><span class="line">&#125;; </span><br><span class="line">var me = new Person(&apos;Zhangsan&apos;); </span><br><span class="line"></span><br><span class="line">me.cry(); //Uncaught TypeError: me.cry is not a function</span><br></pre></td></tr></table></figure>

<p><code>接着是私有属性和方法，其中私有方法又叫特权方法，它既可以访问公有变量又可以访问私有变量：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    //公有变量</span><br><span class="line">    this.name = name;</span><br><span class="line">    //私有变量</span><br><span class="line">    let privateValue = 1;</span><br><span class="line">    //私有方法</span><br><span class="line">    let privateFunc = function()&#123;</span><br><span class="line">        console.log(this.name,privateValue)</span><br><span class="line">    &#125;;</span><br><span class="line">    privateFunc()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(new Persion(&apos;kk&apos;))</span><br></pre></td></tr></table></figure>

<h2 id="ES6类的创建继承"><a href="#ES6类的创建继承" class="headerlink" title="ES6类的创建继承"></a>ES6类的创建继承</h2><p><code>前面说了这么多才把js的类实现好，但每次写代码都要这么麻烦么？幸好es6中已经将刚才所说的内容封装好了，也就是常说的class和extends，大家叫他们是语法糖，实际原理就是上面讲的内容，那来看看到底怎么用es6来实现类的创建与继承</code><br><code>首先是创建：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">	constructor(name)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;;</span><br><span class="line">	sayNmae()&#123;</span><br><span class="line">		console.log(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let animal = new Animal(&apos;小狗&apos;);</span><br><span class="line">console.log(animal.name);</span><br><span class="line">animal.sayNmae(&apos;小汪&apos;)</span><br></pre></td></tr></table></figure>

<p><code>会发现多了一些关键字class和constructor,并且方法也写在了类里面，其中class和原来的function对比来看，说明在使用时只能有new这一种调用方式，而不是像以前一样技能当构造函数又能当普通函数，constructor和原来的this差不多都是指向了当前的对象做完了就把对象返回</code></p>
<p><code>接着是继承：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Dog extends Animal&#123;</span><br><span class="line">	constructor(name,type)&#123;</span><br><span class="line">		super(name);</span><br><span class="line">		this.type = type</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	sound(content)&#123;</span><br><span class="line">		console.log(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dog = new Dog(&apos;小狗&apos;,&apos;aaa&apos;);</span><br><span class="line">console.log(dog.name)</span><br><span class="line">dog.sayNmae()</span><br><span class="line">console.log(dog.type)</span><br><span class="line">dog.sound(&apos;汪汪汪&apos;)</span><br></pre></td></tr></table></figure>

<p><code>同样发现多了一些关键字extends和super(),其中extends相当于原来的Parent.apply(this)，super相当于原来的ClassB.prototype = new ClassA();，也就是指向存放属性和方法的原型对象</code><br><code>ok，至此，关于类的内容完结</code></p>
<div style="text-align:center;margin:30px;font-size:20px;border-radius:5px;border:3px solid #eee; cursor:pointer;" onclick="javascript:window.scrollTo(0, 0)">TOP</div>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
